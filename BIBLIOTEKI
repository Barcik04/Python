|||||||||||||||||||||||||||||||||||||||||||||||||IMPORT math||||||||||||||||||||||||||||||||||||||||||||||||||||||
math.gcd (najwiekszy wspolny dzielnik(dzielnik = (gcd(a,b)))
math.e (liczba eulera)
math.factorial (silnia(e2 += 1/math.factorial(k)))
math.ceil(x) (szacowanie do gory) result = math.ceil(4.2)
math.comb (oblicza liczbe kombinacji z powtorzeniami) c = math.comb(n, k)
math.copysign(x, y) (zwraca liczbe x, ale znak y) math.copysign(10, -2) zworci nam -10.0
math.floor(x) (szacowanie do mniejszej calkowitej)
math.fmod(x, y) (modulo tylko że do liczb float itp.)
math.frexp(x) (rozklada nam np 5 na (0.625, 3) bo 0.625*2^3=5)
math.fsum([5.0, 3.0]) (bardziej precyzyjny sposob sumowania liczb float)
math.isclose(a, b, rel_tol=1, abs_tol=1)  
  a i b to wartości, które chcesz porównać.
  -rel_tol jest maksymalną dopuszczalną różnicą względną między a i b. 
  Domyślnie jest ustawiona na 1e-9, co oznacza, że wartości są uznawane za bliskie, jeśli nie różnią się o więcej niż 1*10^-9 procent ich wartości.
  -abs_tol jest maksymalną dopuszczalną różnicą bezwzględną między a i b. Można ją ustawić, aby zapewnić minimalną różnicę, poniżej której wartości są zawsze uznawane za bliskie, niezależnie od ich wielkości. 
  Domyślnie jest ustawiona na 0.0.
math.isfinite(x) (Zwraca TRUE gdy x jest skonczone, a FALSE jak jest nieskończone)
math.isinf(x) (TRUE jak nieskonczonosc dodatnia FALSE jesli ujemna
math.isnan(x) (czy nieskonczonosc nie jest liczbą (NaN))
math.ldexp(x, i) Return x * (2**i) odwrocenie(math.frexp)
math.nextafter(x, y) (bierze najmniejszą kolejna liczbe float po x dazaca do y)
math.perm(n, k) Return the number of ways to choose k items from n items without repetition and with order.
math.prod([1, 2, 3], start=2) (tutaj liczy iloczyn 1*2*3*2 bo start=2 czyli mnozy jeszcze przez start
math.reminder(x, y) jest to modulo tylko moze zwracac liczby z minusem)
math.sumprod (p = [1, 2, 3] q = [4, 5, 6] result = sumprod(p, q) print(result)  # Wynik to 1*4 + 2*5 + 3*6 = 32)
math.cbrt(x) Return the cube root of x.
math.log2(x) Return the base-2 logarithm of x.




|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||STRINGI|||||||||||||||||||||||||||||||||||||||||||||||||
The strip() method removes any whitespace from the beginning or the end: a = " Hello, World! " print(a.strip()) # returns "Hello, World!" 
The replace() method replaces a string with another string: a = "Hello, World!" print(a.replace("H", "J"))
The split() method splits the string into substrings if it finds instances of the separator: a = "Hello, World!" print(a.split(",")) # returns ['Hello', ' World!']
wynik = "Produkt: {nazwa}, Cena: {cena:.2f} zł, Ilość: {ilosc}".format(nazwa="Książka", cena=39.99, ilosc=3) print(wynik) # Wynik: Produkt: Książka, Cena: 39.99 zł, Ilość: 3
re.match(pattern, string): Sprawdza, czy ciąg znaków string zaczyna się od pasującego do pattern wzorca. Zwraca obiekt dopasowania, jeśli wzorzec został odnaleziony, lub None, jeśli nie.
re.search(pattern, string): Przeszukuje ciąg znaków string w poszukiwaniu pierwszego wystąpienia wzorca pattern. Zwraca obiekt dopasowania, jeśli wzorzec został odnaleziony, lub None, jeśli nie.
re.findall(pattern, string): Znajduje wszystkie niezachodzące na siebie wystąpienia wzorca pattern w ciągu string i zwraca je jako listę.
re.finditer(pattern, string): Podobnie jak findall, ale zamiast zwracać listę pasujących ciągów, zwraca iterator obiektów dopasowania.
re.sub(pattern, repl, string): Zastępuje wszystkie wystąpienia wzorca pattern w ciągu string ciągiem repl i zwraca nowy ciąg znaków.


|||||||||||||||||||||||||||||||||||||||||||||||||||||LISTY||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
wynikowa = [x + y for x, y in zip(list1, list2)] (daje nam sume po takich samych idexach)
for x, y in zip(list1, list2):  print(f"Number: {x}, Letter: {y}") (wypisuje nam x i y z pierwszego indexu a potem w kolejnej linijce znow)
append, extend, insert, remove, pop, clear, index, count, sort, reverse, copy  (funkcje operacji na listach)
zip(list1, list2) (łączy elementy z obu list w pary na podstawie ich indeksów)
all(iterable): Przyjmuje jako argument iterowalny obiekt (takie jak lista lub krotka) i zwraca True, jeśli wszystkie elementy w iterowalnym są prawdziwe (lub jeśli iterowalny jest pusty). Jest to logiczny odpowiednik operacji and dla listy argumentów.
any(iterable): Podobnie jak all(), ale zwraca True, jeśli przynajmniej jeden z elementów w iterowalnym jest prawdziwy. Jest to logiczny odpowiednik operacji or dla listy argumentów.
